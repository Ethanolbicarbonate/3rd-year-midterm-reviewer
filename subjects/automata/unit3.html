<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 3: Formal Languages - Automata CCS 226</title>
    <link rel="stylesheet" href="../../css/styles.css">
</head>
<body>
    <nav class="main-nav">
        <div class="nav-container">
            <div class="logo">
                <a href="../../index.html">📚 Komsai Reviewer</a>
            </div>
            <div class="nav-menu" id="navMenu">
                <!-- Dynamically populated by JS -->
            </div>
            <div class="hamburger" id="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <div class="chapter-container">
        <aside class="sidebar" id="sidebar">
            <h3>Quick Navigation</h3>
            <div class="section-links" id="sectionLinks">
                <!-- Auto-populated based on content sections -->
            </div>
        </aside>

        <main class="chapter-main">
            <header class="chapter-header">
                <div class="breadcrumb">
                    <a href="../../index.html">Home</a> / 
                    <span>Automata CCS 226</span> / 
                    <span>Unit 3: Formal Languages</span>
                </div>
                <h1 class="chapter-title">Unit 3: Formal Languages</h1>
            </header>

            <section class="content-area">
                <!-- Main content sections -->
                <div class="content-section">
                    <h2 class="section-title">Introduction to Formal Languages</h2>
                    <div class="content-block info-block">
                        <p>Formal languages are sets of strings composed of symbols from an alphabet, defined by a specific set of rules called a grammar. They form a hierarchy of complexity and are fundamental to understanding computation, compilers, and language processing.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2 class="section-title">Regular Languages (RL)</h2>
                    <div class="content-block info-block">
                        <p><strong>Regular Languages</strong> are the most restricted class of formal languages. They are characterized by their simple structure, often involving repeating patterns, and can be defined using regular expressions or recognized by finite automata.</p>
                    </div>
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li>They can be recognized by <strong>finite automata (FA)</strong>.</li>
                        <li>They can be described using <strong>regular expressions</strong>.</li>
                        <li>They have a simple structure, typically involving repetition.</li>
                    </ul>
                    <h3>Closure Properties</h3>
                    <p>Regular languages are "closed" under certain operations, meaning that if you perform these operations on regular languages, the result is always another regular language.</p>
                    <div class="concept-cards">
                        <div class="concept-card secondary-concept"><h4>Union</h4><p>If L_1 and L_2 are regular languages, then L_1 + L_2 is also a regular language.</p></div>
                        <div class="concept-card secondary-concept"><h4>Concatenation</h4><p>If L_1 and L_2 are regular languages, then L_1.L_2 is also a regular language.</p></div>
                        <div class="concept-card secondary-concept"><h4>Kleene Star</h4><p>If L is a regular language, then L^* (zero or more repetitions) is also a regular language.</p></div>
                    </div>
                     <h3>Applications of Regular Languages</h3>
                    <div class="note-block success">
                        <ul>
                            <li><strong>Pattern Matching:</strong> Used in text editors and programming languages for searching strings (e.g., finding all email addresses in a document).</li>
                            <li><strong>Lexical Analysis:</strong> Used in compilers to tokenize source code into keywords, identifiers, and operators.</li>
                            <li><strong>Input Validation:</strong> Validating user input in forms to ensure it matches a specific format (e.g., phone numbers, postal codes).</li>
                            <li><strong>Network Protocols:</strong> Defining the syntax of messages in protocols like HTTP and SMTP.</li>
                        </ul>
                    </div>
                    <div class="example-block">
                        <h4>Example: Email Validation with a Regular Expression</h4>
                        <p>To validate an email address in a web form, a regular expression can be used:</p>
                        <pre class="code-block"><code>[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}</code></pre>
                        <p>This expression defines the pattern for a valid email, ensuring it has a user part, an '@' symbol, a domain, a dot, and a top-level domain.</p>
                    </div>
                </div>
                
                <div class="content-section">
                    <h2 class="section-title">Context-Free Languages (CFL)</h2>
                    <div class="content-block info-block">
                        <p><strong>Context-Free Languages (<span class="term">CFLs</span>)</strong> are a class of formal languages that can be generated by a <strong>Context-Free Grammar (<span class="term">CFG</span>)</strong>. A CFG is a set of production rules that define how to generate strings in a language. These languages are more expressive than regular languages and can describe nested structures.</p>
                    </div>
                    <h3>Production Rules</h3>
                    <p>Production rules in a CFG define how variables (non-terminals) can be replaced by a sequence of variables and terminals. The rules are "context-free" because a variable can be replaced regardless of the context in which it appears.</p>
                    <div class="example-block">
                        <h4>Example: Grammar for \(a^nb^n\)</h4>
                        <p>The following CFG generates the language of strings with some number of 'a's followed by an equal number of 'b's.</p>
                        <pre class="code-block"><code>1. S → aSb
2. S → ε</code></pre>
                        <ul>
                            <li>The first rule states that a variable `S` can be rewritten as an `a`, followed by `S`, followed by a `b`. This allows for recursive nesting.</li>
                            <li>The second rule states that `S` can be replaced by `ε` (the empty string), which terminates the recursion.</li>
                        </ul>
                        <p>To generate the string "aabb":</p>
                        <p>Derivation: <code>S → aSb → aaSbb → aabb</code></p>
                    </div>
                    <h3>Applications of CFLs</h3>
                    <div class="note-block success">
                        <ul>
                            <li><strong>Programming Languages:</strong> The syntax of most programming languages is defined by a CFG, which allows compilers to parse and understand the code's structure.</li>
                            <li><strong>Natural Language Processing (NLP):</strong> Used to parse the structure of human language sentences and identify parts of speech.</li>
                            <li><strong>Document Formats:</strong> Defines the structure of valid documents like HTML and XML.</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2 class="section-title">Context-Sensitive Languages (CSL)</h2>
                    <div class="content-block info-block">
                        <p><strong>Context-Sensitive Languages (<span class="term">CSLs</span>)</strong> are a class of formal languages that are more expressive than CFLs. They are defined by <strong>Context-Sensitive Grammars (<span class="term">CSGs</span>)</strong>, whose production rules can refer to the context in which a variable appears.</p>
                    </div>
                    <h3>Difference between CFL and CSL Rules</h3>
                    <p>The key difference is that CSL rules can be conditional, while CFL rules are not.</p>
                    <div class="concept-cards">
                        <div class="concept-card primary-concept">
                            <h4>Context-Free Rule</h4>
                            <pre><code>S → aSb | bSa</code></pre>
                            <p>This rule can be applied to the variable `S` <strong>regardless</strong> of the context in which it appears.</p>
                        </div>
                        <div class="concept-card primary-concept">
                            <h4>Context-Sensitive Rule</h4>
                            <pre><code>S → aSb | bSa $</code></pre>
                            <p>This rule can only be applied to the variable `S` when it is <strong>followed by</strong> the end-of-string marker `$`. This makes the rule context-sensitive.</p>
                        </div>
                    </div>
                     <h3>Applications and Challenges</h3>
                     <div class="note-block success">
                        <strong>Applications:</strong> CSLs are used in NLP and compiler design for languages with complex syntactic features that CFLs cannot handle, such as long-distance dependencies.
                    </div>
                    <div class="note-block warning">
                        <strong>Challenges:</strong> CSLs are more complex to implement and analyze than CFLs. There are also fewer tools and resources available for working with them because they are less widely used in practice.
                    </div>
                </div>

            </section>

            <section class="memorization-area">
                <h2 class="mem-header">📝 Quick Review & Memorization</h2>
                
                <div class="mem-section">
                    <h3>Key Terms & Acronyms</h3>
                    <ol>
                        <li><span class="term">Formal Language</span>: A set of strings defined by a specific set of rules (a grammar).</li>
                        <li><span class="term">Regular Language (RL)</span>: The simplest class of formal languages, recognized by finite automata.</li>
                        <li><span class="term">Regular Expression (Regex)</span>: A sequence of characters that specifies a search pattern, used to define regular languages.</li>
                        <li><span class="term">Context-Free Language (CFL)</span>: A language generated by a context-free grammar, recognized by pushdown automata.</li>
                        <li><span class="term">CFG (Context-Free Grammar)</span>: A set of production rules used to generate strings in a CFL. The rules are applied regardless of context.</li>
                        <li><span class="term">Context-Sensitive Language (CSL)</span>: A language generated by a context-sensitive grammar, where rules can depend on the context.</li>
                        <li><span class="term">Production Rule</span>: A rule in a grammar that defines how a symbol can be rewritten (e.g., `S → aSb`).</li>
                        <li><span class="term">Start Symbol</span>: The initial variable from which all strings in a language are derived.</li>
                        <li><span class="term">Terminal Symbol</span>: The basic symbols from which strings are formed (e.g., 'a', 'b').</li>
                        <li><span class="term">ε (Epsilon)</span>: Represents the empty string.</li>
                    </ol>
                </div>

                <div class="mem-section">
                    <h3>Summary Points</h3>
                    <ol>
                        <li>Formal languages are categorized by their complexity, most famously in the Chomsky Hierarchy.</li>
                        <li><strong>Regular Languages</strong> are the simplest, used for pattern matching and lexical analysis, and are recognized by finite automata.</li>
                        <li><strong>Context-Free Languages</strong> are more powerful, can describe nested structures like those in programming languages and XML, and are recognized by pushdown automata.</li>
                        <li><strong>Context-Sensitive Languages</strong> are even more powerful, as their grammars can consider the context of a variable before applying a rule.</li>
                        <li>The key difference between a CFL and a CSL is whether the grammar's production rules depend on the surrounding symbols (context).</li>
                    </ol>
                </div>

                <div class="mem-section">
                    <h3>Important Enumerations</h3>
                    <ol>
                        <li><strong>Language Hierarchy (Simplest to Most Complex):</strong>
                            <ul>
                                <li>Regular Languages (RL)</li>
                                <li>Context-Free Languages (CFL)</li>
                                <li>Context-Sensitive Languages (CSL)</li>
                            </ul>
                        </li>
                        <li><strong>Closure Properties of Regular Languages:</strong>
                            <ul>
                                <li>Union</li>
                                <li>Concatenation</li>
                                <li>Kleene Star</li>
                            </ul>
                        </li>
                        <li><strong>Key Applications of Context-Free Grammars (CFGs):</strong>
                            <ul>
                                <li>Defining programming language syntax.</li>
                                <li>Parsing in compilers and interpreters.</li>
                                <li>Structuring documents like XML and HTML.</li>
                                <li>Natural Language Processing.</li>
                            </ul>
                        </li>
                    </ol>
                </div>
            </section>

            <nav class="chapter-nav">
                <a href="#" class="nav-btn prev-btn">← Previous Chapter</a>
                <a href="#" class="nav-btn next-btn">Next Chapter →</a>
            </nav>
        </main>
    </div>

    <script src="../../js/navigation.js"></script>
    <script src="../../js/chapter.js"></script>
</body>
</html>